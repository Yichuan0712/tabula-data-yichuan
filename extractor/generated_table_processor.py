

import json
from typing import Any, Dict, List, Optional
import logging

logger = logging.getLogger(__name__)

from extractor.constants import PKSUMMARY_TABLE_OUTPUT_COLUMNS
from extractor.utils import convert_digit_with_comma_to_digit

class GeneratedPKSummaryTableProcessor(object):
    """
    This class is to process the content generated by LLM:
    1. check the format of the content.
    2. If the content is not in csv format, we will convert to csv format
    """
    def __init__(
        self, 
        delimiter: Optional[str] = ', ', 
    ):
        self.delimiter = delimiter
        temp_columns, temp_columns_dict = self._get_prompts_columns_and_columns_dict()
        self.columns = temp_columns
        self.lower_columns = list(map(lambda x: x.lower(), self.columns))
        self.columns_dict = temp_columns_dict

    def process_content(self, content: str) -> str:
        content = self._strip_table_content(content)
        if self._check_content_format(content) == "json":
            content = self._validate_json_content(content)
            return self._convert_json_to_csv(content)
        else:
            return content
        
    def _get_prompts_columns_and_columns_dict(self):
          with open("./prompts/pk_prompts.json", "r") as fobj:
              json_obj = json.load(fobj)
              return (
                  json_obj["table_extraction_prompts"]["output_columns"], 
                  json_obj["table_extraction_prompts"]["output_columns_map"]
              )
    def _get_fullname_headers(self)->List[str]:
        return list(map(lambda item: item[1], self.columns_dict))
    
    def _convert_to_csv_header(self) -> str:
        headers = self._get_fullname_headers()
        csv_headers = self.delimiter.join(headers)
        return csv_headers
    
    def _convert_to_csv_row(self, row: Dict[str, Any]) -> str:
        lower_key_row = {}
        for k in row:
            lower_key_row[k.lower()] = row[k]
        vals = ""
        col_cnt = len(self.lower_columns)
        for ix, col in enumerate(self.lower_columns):
            if col in lower_key_row:
                the_val = lower_key_row[col]
                the_val = f"{the_val}"
                the_val = convert_digit_with_comma_to_digit(the_val)
                if isinstance(the_val, str) and "," in the_val:
                    the_val = the_val.replace(',', ' ')
                vals += the_val
            vals += self.delimiter
        vals = vals[:-2] # remove the last delimiter
        return vals
    
    def _convert_json_to_csv(self, content: str) -> str | None:
        stripped_content = content.strip()
        if stripped_content.startswith('['):
            stripped_content = '{' + f'"content": {stripped_content}' + '}'
        try:
            json_obj = json.loads(stripped_content)
            csv_str = self._convert_to_csv_header()
            csv_str += "\n"
            rows: List = json_obj["content"]
            for ix, row in enumerate(rows):
                csv_str += self._convert_to_csv_row(row)
                csv_str += "\n"
            return csv_str
        except Exception as e:
            logger.error(e)
            return None
    def _strip_table_content(self, content: str) -> str:
        """
        This function is to remove redundant characters, like white spaces, 
        ```json ... ``` or ```csv ... ```
        """
        strp_content = content.strip()
        if strp_content.startswith("```json"):
            strp_content = strp_content[7:]
        if strp_content.startswith("```csv"):
            strp_content = strp_content[6:]
        if strp_content.endswith("```"):
            strp_content = strp_content[:-3]
        return strp_content.strip()
    def _validate_json_content(self, content: str) -> str:
        if content.endswith("```"):
            return content[:-3]
        return content
    def _check_content_format(self, content: str) -> str:
        stripped_content = content.strip()
        if stripped_content.startswith('[') or stripped_content.startswith('{'):
            return "json"
        else:
            return "csv"
